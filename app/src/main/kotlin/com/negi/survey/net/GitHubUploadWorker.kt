/*
 * =====================================================================
 *  IshizukiTech LLC ‚Äî SLM Integration Framework
 *  ---------------------------------------------------------------------
 *  File: GitHubUploadWorker.kt
 *  Author: Shu Ishizuki (Áü≥ÈôÑ ÊîØ)
 *  License: MIT License
 *  ¬© 2025 IshizukiTech LLC. All rights reserved.
 * =====================================================================
 *
 *  Summary:
 *  ---------------------------------------------------------------------
 *  Foreground-capable WorkManager coroutine worker that uploads one
 *  local JSON payload to GitHub using the REST "Create or Update File
 *  Contents" API via [GitHubUploader].
 *
 *  This worker ensures compliance with Android 14+ background execution
 *  limits by declaring the `DATA_SYNC` foreground service type and by
 *  maintaining visible progress notifications during upload.
 *
 *  Features:
 *   ‚Ä¢ Safe, resumable background upload (WorkManager + Foreground Service)
 *   ‚Ä¢ Determinate progress reporting via both notification and WorkData
 *   ‚Ä¢ Automatic exponential backoff retry on transient failures
 *   ‚Ä¢ Robust input validation and output data reporting
 *   ‚Ä¢ Automatic deletion of successfully uploaded local files
 *
 *  Typical usage:
 *  ---------------------------------------------------------------------
 *  ```kotlin
 *  val cfg = GitHubUploader.GitHubConfig(
 *      owner = "ishizuki-tech",
 *      repo = "AndroidSLM",
 *      token = GITHUB_TOKEN
 *  )
 *
 *  GitHubUploadWorker.enqueue(context, cfg, "result_2025_11_05", jsonString)
 *  ```
 * =====================================================================
 */

package com.negi.survey.net

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Context
import android.content.pm.ServiceInfo
import android.os.Build
import androidx.annotation.RequiresApi
import androidx.core.app.NotificationCompat
import androidx.work.BackoffPolicy
import androidx.work.Constraints
import androidx.work.CoroutineWorker
import androidx.work.ExistingWorkPolicy
import androidx.work.ForegroundInfo
import androidx.work.NetworkType
import androidx.work.OneTimeWorkRequestBuilder
import androidx.work.OutOfQuotaPolicy
import androidx.work.WorkManager
import androidx.work.WorkRequest
import androidx.work.WorkerParameters
import androidx.work.workDataOf
import com.negi.survey.R
import java.io.File
import java.util.concurrent.TimeUnit
import kotlin.math.abs
import kotlin.math.max

/**
 * Coroutine-based [WorkManager] worker responsible for uploading one local JSON file
 * to GitHub via [GitHubUploader]. Runs as a **foreground service** on Android 10+
 * (required for visible long-running background operations such as data syncs).
 *
 * This worker is designed for reliable background uploads of survey logs, model
 * outputs, or diagnostic payloads generated by the SLM framework.
 *
 * ### Core Responsibilities
 * - Read the specified file from `/files/pending_uploads`.
 * - Stream the file contents to GitHub (with visible progress updates).
 * - Handle automatic retries using exponential backoff.
 * - Clean up successfully uploaded files.
 *
 * ### Foreground Behavior
 * On Android 14 and higher, this worker declares
 * `ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC` to comply with new restrictions.
 *
 * @constructor Primary constructor invoked internally by WorkManager.
 * @param appContext The [Context] in which the worker runs.
 * @param params Input parameters supplied via [WorkRequest].
 */
class GitHubUploadWorker(
    appContext: Context,
    params: WorkerParameters
) : CoroutineWorker(appContext, params) {

    /**
     * Main coroutine entry point for WorkManager execution.
     * Performs input validation, progress reporting, and upload lifecycle management.
     *
     * @return [Result.success] on success, [Result.retry] on transient failure,
     *         or [Result.failure] when unrecoverable.
     */
    @RequiresApi(Build.VERSION_CODES.Q)
    override suspend fun doWork(): Result {
        // ------------------------------------------------------------
        // 1Ô∏è‚É£ Parse and validate inputs
        // ------------------------------------------------------------
        val cfg = GitHubUploader.GitHubConfig(
            owner = inputData.getString(KEY_OWNER).orEmpty(),
            repo = inputData.getString(KEY_REPO).orEmpty(),
            token = inputData.getString(KEY_TOKEN).orEmpty(),
            branch = inputData.getString(KEY_BRANCH).orEmpty(),
            pathPrefix = inputData.getString(KEY_PATH_PREFIX).orEmpty()
        )

        val filePath = inputData.getString(KEY_FILE_PATH).orEmpty()
        val fileName = inputData.getString(KEY_FILE_NAME) ?: File(filePath).name

        // Validate configuration and inputs early
        if (cfg.owner.isBlank() || cfg.repo.isBlank() || cfg.token.isBlank())
            return Result.failure(workDataOf(ERROR_MESSAGE to "Invalid GitHub configuration (owner/repo/token)."))

        if (filePath.isBlank())
            return Result.failure(workDataOf(ERROR_MESSAGE to "Missing file path."))

        val pendingFile = File(filePath)
        if (!pendingFile.exists())
            return Result.failure(workDataOf(ERROR_MESSAGE to "Pending file not found: $filePath"))

        // Construct the remote upload path (e.g. "exports/results_2025.json")
        val remotePath = buildRemotePath(cfg.pathPrefix, fileName)

        // ------------------------------------------------------------
        // 2Ô∏è‚É£ Prepare notification (required for foreground execution)
        // ------------------------------------------------------------
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) ensureChannel()
        val notifId = NOTIF_BASE + (abs(fileName.hashCode()) % 8000)
        setForegroundAsync(foregroundInfo(notifId, 0, "Uploading $fileName"))

        // ------------------------------------------------------------
        // 3Ô∏è‚É£ Load file content into memory
        // ------------------------------------------------------------
        val json = runCatching { pendingFile.readText(Charsets.UTF_8) }.getOrElse {
            return Result.failure(workDataOf(ERROR_MESSAGE to "Failed to read file: ${it.message}"))
        }

        var lastPct = 0

        // ------------------------------------------------------------
        // 4Ô∏è‚É£ Execute upload and update progress in real time
        // ------------------------------------------------------------
        return try {
            val result = GitHubUploader.uploadJson(
                owner = cfg.owner,
                repo = cfg.repo,
                branch = cfg.branch,
                path = remotePath,
                token = cfg.token,
                content = json
            ) { pct ->
                lastPct = pct.coerceIn(0, 100)
                setProgressAsync(workDataOf(PROGRESS_PCT to lastPct, PROGRESS_FILE to fileName))
                setForegroundAsync(foregroundInfo(notifId, lastPct, "Uploading $fileName"))
            }

            // --------------------------------------------------------
            // 5Ô∏è‚É£ Finalization: mark as success and clean up
            // --------------------------------------------------------
            setProgressAsync(workDataOf(PROGRESS_PCT to 100, PROGRESS_FILE to fileName))
            setForegroundAsync(foregroundInfo(notifId, 100, "Uploaded $fileName", finished = true))
            runCatching { pendingFile.delete() }

            Result.success(
                workDataOf(
                    OUT_FILE_NAME to fileName,
                    OUT_REMOTE_PATH to remotePath,
                    OUT_COMMIT_SHA to (result.commitSha ?: ""),
                    OUT_FILE_URL to (result.fileUrl ?: "")
                )
            )

        } catch (t: Throwable) {
            // --------------------------------------------------------
            // 6Ô∏è‚É£ Failure path: display failure and schedule retry
            // --------------------------------------------------------
            setForegroundAsync(
                foregroundInfo(
                    notifId,
                    max(0, lastPct),
                    "Upload failed: $fileName",
                    error = true
                )
            )
            val failData = workDataOf(ERROR_MESSAGE to (t.message ?: "Unknown error"))
            if (runAttemptCount < MAX_ATTEMPTS) Result.retry() else Result.failure(failData)
        }
    }

    // -----------------------------------------------------------------
    // üîß Utility Functions
    // -----------------------------------------------------------------

    /**
     * Builds a normalized remote path combining prefix and file name.
     * Example: `"exports" + "data.json"` ‚Üí `"exports/data.json"`
     */
    private fun buildRemotePath(prefix: String, fileName: String): String =
        listOf(prefix.trim('/'), fileName.trim('/'))
            .filter { it.isNotEmpty() }
            .joinToString("/")

    /**
     * Creates a [ForegroundInfo] object with a notification that reflects
     * current upload progress, success, or failure.
     *
     * @param notificationId Stable per-file ID to avoid collisions.
     * @param pct Progress percentage (0‚Äì100).
     * @param title Notification title text.
     * @param finished Whether upload is fully completed.
     * @param error Whether this notification represents an error state.
     */
    @RequiresApi(Build.VERSION_CODES.Q)
    private fun foregroundInfo(
        notificationId: Int,
        pct: Int,
        title: String,
        finished: Boolean = false,
        error: Boolean = false
    ): ForegroundInfo {
        val builder = NotificationCompat.Builder(applicationContext, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_upload)
            .setContentTitle(title)
            .setOnlyAlertOnce(true)
            .setOngoing(!finished && !error)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setCategory(NotificationCompat.CATEGORY_PROGRESS)

        if (finished || error)
            builder.setProgress(0, 0, false)
        else
            builder.setProgress(100, pct.coerceIn(0, 100), false)

        return ForegroundInfo(
            notificationId,
            builder.build(),
            ServiceInfo.FOREGROUND_SERVICE_TYPE_DATA_SYNC
        )
    }

    /**
     * Ensures the existence of the notification channel for foreground uploads.
     * Safe to call multiple times; does nothing if already created.
     */
    @RequiresApi(Build.VERSION_CODES.O)
    private fun ensureChannel() {
        val nm =
            applicationContext.getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        val channel = NotificationChannel(
            CHANNEL_ID,
            "Background Uploads",
            NotificationManager.IMPORTANCE_LOW
        ).apply {
            description = "Displays progress for ongoing uploads to GitHub."
            setShowBadge(false)
        }
        nm.createNotificationChannel(channel)
    }

    // -----------------------------------------------------------------
    // ‚öôÔ∏è Companion Object: Constants & Enqueue Utilities
    // -----------------------------------------------------------------
    companion object {

        /** Tag used for identifying GitHub upload work requests. */
        const val TAG = "github_upload"

        /** Notification channel ID for upload progress. */
        private const val CHANNEL_ID = "uploads"

        /** Base ID offset for unique per-file notifications. */
        private const val NOTIF_BASE = 3200

        /** Maximum number of retry attempts before final failure. */
        private const val MAX_ATTEMPTS = 5

        // Progress keys (emitted in intermediate workData)
        const val PROGRESS_PCT = "pct"
        const val PROGRESS_FILE = "file"

        // Input keys (provided via workDataOf)
        const val KEY_OWNER = "owner"
        const val KEY_REPO = "repo"
        const val KEY_TOKEN = "token"
        const val KEY_BRANCH = "branch"
        const val KEY_PATH_PREFIX = "pathPrefix"
        const val KEY_FILE_PATH = "filePath"
        const val KEY_FILE_NAME = "fileName"

        // Output keys (emitted in Result.success)
        const val OUT_FILE_NAME = "out.fileName"
        const val OUT_REMOTE_PATH = "out.remotePath"
        const val OUT_COMMIT_SHA = "out.commitSha"
        const val OUT_FILE_URL = "out.fileUrl"

        /** Output key for human-readable error messages. */
        const val ERROR_MESSAGE = "error"

        /**
         * Enqueues a work request to upload an existing file.
         *
         * - Enforced unique per file to prevent duplicate uploads.
         * - Requires an active network connection.
         * - Applies exponential backoff with a 30s initial delay.
         * - Runs expedited when WorkManager quota allows.
         *
         * @param context The [Context] to use for [WorkManager] operations.
         * @param cfg The [GitHubUploader.GitHubConfig] defining upload target.
         * @param file The file to upload.
         */
        fun enqueueExistingPayload(context: Context, cfg: GitHubUploader.GitHubConfig, file: File) {
            val name = file.name
            val req = OneTimeWorkRequestBuilder<GitHubUploadWorker>()
                .setInputData(
                    workDataOf(
                        KEY_OWNER to cfg.owner,
                        KEY_REPO to cfg.repo,
                        KEY_TOKEN to cfg.token,
                        KEY_BRANCH to cfg.branch,
                        KEY_PATH_PREFIX to cfg.pathPrefix,
                        KEY_FILE_PATH to file.absolutePath,
                        KEY_FILE_NAME to name
                    )
                )
                .setConstraints(
                    Constraints.Builder()
                        .setRequiredNetworkType(NetworkType.CONNECTED)
                        .build()
                )
                .setBackoffCriteria(BackoffPolicy.EXPONENTIAL, 30, TimeUnit.SECONDS)
                .setExpedited(OutOfQuotaPolicy.RUN_AS_NON_EXPEDITED_WORK_REQUEST)
                .addTag(TAG)
                .addTag("$TAG:file:$name")
                .build()

            WorkManager.getInstance(context)
                .enqueueUniqueWork("upload_$name", ExistingWorkPolicy.KEEP, req)
        }

        /**
         * Writes the given JSON content into `/files/pending_uploads` and
         * schedules an upload work for it.
         *
         * If a file with the same name already exists, a unique suffix (`_1`, `_2`, ‚Ä¶)
         * is appended to avoid overwriting existing payloads.
         *
         * @param context Application context.
         * @param cfg GitHub upload configuration.
         * @param fileName Desired file name (e.g., `"results_2025.json"`).
         * @param jsonContent The serialized JSON string to store and upload.
         */
        fun enqueue(
            context: Context,
            cfg: GitHubUploader.GitHubConfig,
            fileName: String,
            jsonContent: String
        ) {
            require(fileName.isNotBlank()) { "fileName is blank." }

            val safeName =
                sanitizeName(fileName).let { if (it.endsWith(".json", true)) it else "$it.json" }
            val dir = File(context.filesDir, "pending_uploads").apply { mkdirs() }
            val target = uniqueIfExists(File(dir, safeName))

            target.writeText(jsonContent, Charsets.UTF_8)
            enqueueExistingPayload(context, cfg, target)
        }

        /**
         * Replaces all non `[A-Za-z0-9_.-]` characters with underscores to
         * produce a safe and portable file name.
         */
        private fun sanitizeName(name: String): String =
            name.replace(Regex("""[^\w\-.]"""), "_")

        /**
         * If the specified file already exists, appends a numeric suffix (`_1`, `_2`, ‚Ä¶)
         * until a non-existing candidate is found.
         *
         * @param file Desired output file path.
         * @return A unique, writable [File] object.
         */
        private fun uniqueIfExists(file: File): File {
            if (!file.exists()) return file
            val base = file.nameWithoutExtension
            val ext = file.extension.takeIf { it.isNotEmpty() }?.let { ".$it" } ?: ""
            var idx = 1
            while (true) {
                val candidate = File(file.parentFile, "${base}_$idx$ext")
                if (!candidate.exists()) return candidate
                idx++
            }
        }
    }
}
